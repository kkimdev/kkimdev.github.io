"use strict";(globalThis.webpackChunkkkimdev=globalThis.webpackChunkkkimdev||[]).push([[965],{1942:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var i=n(6807),s=n(7259),a=n(9087);const o={draft:!1,title:"IEEE 754 Floating-Point Types in C++",authors:"kkimdev"},r=void 0,c={authorsImageUrls:[void 0]},d=[];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["If you want to use IEEE 754 32-bit or 64-bit floating-point types in C++, you might think of using ",(0,s.jsx)(t.code,{children:"float"})," and ",(0,s.jsx)(t.code,{children:"double"}),". Unfortunately, the C++ standard offers very few guarantees about its built-in floating-point types."]}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"http://eel.is/c++draft/basic.fundamental#8",children:"\xa7 6.7.1.8"})," There are three\nfloating-point types: float, double, and long double. The type double provides\nat least as much precision as float, and the type long double provides at\nleast as much precision as double. The set of values of the type float is a\nsubset of the set of values of the type double; the set of values of the type\ndouble is a subset of the set of values of the type long double. ",(0,s.jsx)(t.strong,{children:"The value\nrepresentation of floating-point types is implementation-defined"}),". ..."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["So, are we doomed? Not at all. C++ provides ",(0,s.jsx)(t.a,{href:"http://en.cppreference.com/w/cpp/types/numeric_limits",children:(0,s.jsx)(t.code,{children:"std::numeric_limits"})}),", which gives us information about floating-point type traits. We can combine this with some neat compile-time tricks to craft a clean type API. Let's see how. The goal is to construct the following IEEE 754 floating-point types:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:'#include <iostream>\n#include "ieee754_types.hpp"\n\nint main() {\n  IEEE_754_2008_Binary<32> x = 1.0;\n  IEEE_754_2008_Binary<64> y = 2.0;\n\n  std::cout << x + y << std::endl;\n\n  // Compile-time error if the requested type doesn\'t exist on the system.\n  // IEEE_754_2008_Binary<16> z;\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Here, ",(0,s.jsx)(t.code,{children:"IEEE_754_2008_Binary<n>"})," is an n-bit IEEE 754 floating-point type. On most systems, ",(0,s.jsx)(t.code,{children:"IEEE_754_2008_Binary<32>"})," will be ",(0,s.jsx)(t.code,{children:"float"})," and ",(0,s.jsx)(t.code,{children:"IEEE_754_2008_Binary<64>"})," will be ",(0,s.jsx)(t.code,{children:"double"}),". If a requested type like ",(0,s.jsx)(t.code,{children:"IEEE_754_2008_Binary<16>"})," is not available, we should get a compile-time error with a clear message."]}),"\n",(0,s.jsxs)(t.p,{children:["At this point, you might naturally ask, \"Do we really need this? Can't we just assume ",(0,s.jsx)(t.code,{children:"float"})," and ",(0,s.jsx)(t.code,{children:"double"}),' are IEEE 754, since they are on 99.9% of systems?" I used to think so, but I later found that others have submitted related proposals, like ',(0,s.jsx)(t.a,{href:"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1703.pdf",children:"N1703"})," and ",(0,s.jsx)(t.a,{href:"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3626.pdf",children:"N3626"}),", to the C and C++ standards committees to address this issue by adding standard types like ",(0,s.jsx)(t.code,{children:"float16_t"}),", ",(0,s.jsx)(t.code,{children:"float32_t"}),", ",(0,s.jsx)(t.code,{children:"float64_t"}),", and ",(0,s.jsx)(t.code,{children:"float128_t"}),". So, perhaps this effort isn't entirely pointless. With that, let's get started."]}),"\n",(0,s.jsxs)(t.p,{children:["First, let's create a way to check if a given type ",(0,s.jsx)(t.code,{children:"T"})," fulfills the IEEE 754 standard and our other conditions."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"template <int storage_bits, int exponent_bits, int mantissa_bits>\nstruct Is_Ieee754_2008_Binary_Interchange_Format {\n  template <typename T>\n  static constexpr bool value =\n      ::std::is_floating_point<T>()            &&\n      ::std::numeric_limits<T>::is_iec559      &&\n      ::std::numeric_limits<T>::radix == 2     &&\n      get_storage_bits<T>() == storage_bits    &&\n      get_exponent_bits<T>() == exponent_bits  &&\n      get_mantissa_bits<T>() == mantissa_bits;\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We use a ",(0,s.jsx)(t.a,{href:"https://en.cppreference.com/w/cpp/language/variable_template",children:"variable template"})," for the type-dependent boolean check and wrap it in a template ",(0,s.jsx)(t.code,{children:"struct"}),". This makes it easy to pass around as a type template parameter later."]}),"\n",(0,s.jsxs)(t.p,{children:["First, we check if ",(0,s.jsx)(t.code,{children:"T"})," complies with IEEE 754 (equivalently, ",(0,s.jsx)(t.a,{href:"https://www.iso.org/standard/57469.html",children:"IEC 60559"}),") using ",(0,s.jsx)(t.a,{href:"https://en.cppreference.com/w/cpp/types/numeric_limits/is_iec559",children:(0,s.jsx)(t.code,{children:"std::numeric_limits<T>::is_iec559"})}),". We also check ",(0,s.jsx)(t.code,{children:"radix == 2"})," because IEEE 754 defines two types of floating-point numbers: binary and decimal. Finally, we check if ",(0,s.jsx)(t.code,{children:"T"})," has the requested number of storage (width), exponent, and mantissa bits. Although IEEE 754 defines a standard number of exponent and mantissa bits for certain sizes (16, 32, 64, 128, etc.), it also allows implementations to have arbitrary sizes and bit counts (e.g., the ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Extended_precision#x86_extended_precision_format",children:"x86 extended precision format"}),"). Therefore, we need to check that ",(0,s.jsx)(t.code,{children:"T"})," has the exact format we want."]}),"\n",(0,s.jsxs)(t.p,{children:["We can calculate the number of bits for ",(0,s.jsx)(t.code,{children:"T"})," with the following simple compile-time functions:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"template <typename T>\nconstexpr int get_storage_bits() {\n  return sizeof(T) * CHAR_BIT;\n}\n\ntemplate <typename T>\nconstexpr int get_exponent_bits() {\n  int exponent_range = ::std::numeric_limits<T>::max_exponent -\n                       ::std::numeric_limits<T>::min_exponent;\n  int bits = 0;\n  while ((exponent_range >> bits) > 0) ++bits;\n  return bits;\n}\n\ntemplate <typename T>\nconstexpr int get_mantissa_bits() {\n  return ::std::numeric_limits<T>::digits - 1;\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["For the mantissa bits, ",(0,s.jsx)(t.code,{children:"std::numeric_limits<T>::digits"})," includes the implicit leading bit for normalized numbers, so we subtract 1 to get the number of explicit mantissa bits. For the exponent bits, a direct property is not available in ",(0,s.jsx)(t.code,{children:"std::numeric_limits"}),", so we instead calculate the minimum number of bits required to represent its exponent range."]}),"\n",(0,s.jsxs)(t.p,{children:["Now we have everything needed to determine if a given ",(0,s.jsx)(t.code,{children:"T"})," is the type we're looking for. The next step is to automatically select such a type from the built-in floating-point types (",(0,s.jsx)(t.code,{children:"float"}),", ",(0,s.jsx)(t.code,{children:"double"}),", and ",(0,s.jsx)(t.code,{children:"long double"}),"), given a size in bits (e.g., 32, 64). This is where it gets interesting."]}),"\n",(0,s.jsxs)(t.p,{children:["The following recursive function, ",(0,s.jsx)(t.code,{children:"find_type()"}),", selects a type from ",(0,s.jsx)(t.code,{children:"T"})," and ",(0,s.jsx)(t.code,{children:"Ts..."})," that satisfies the condition ",(0,s.jsx)(t.code,{children:"C"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"template <typename C, typename T, typename... Ts>\nconstexpr auto find_type() {\n  throw;\n\n  if constexpr (C::template value<T>) {\n    return T();\n  } else if constexpr (sizeof...(Ts) >= 1) {\n    return find_type<C, Ts...>();\n  } else {\n    return void();\n  }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In our case, the types to search (",(0,s.jsx)(t.code,{children:"T"})," and ",(0,s.jsx)(t.code,{children:"Ts..."}),") will be ",(0,s.jsx)(t.code,{children:"float"}),", ",(0,s.jsx)(t.code,{children:"double"}),", and ",(0,s.jsx)(t.code,{children:"long double"}),". The condition ",(0,s.jsx)(t.code,{children:"C"})," is the ",(0,s.jsx)(t.code,{children:"Is_Ieee754_2008_Binary_Interchange_Format<...>"})," struct we defined previously."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"typename... Ts"})," is a ",(0,s.jsx)(t.a,{href:"https://en.cppreference.com/w/cpp/language/parameter_pack",children:"parameter pack"})," that can match any number of types. The first ",(0,s.jsx)(t.code,{children:"if"})," condition, ",(0,s.jsx)(t.code,{children:"C::template value<T>"}),", checks if ",(0,s.jsx)(t.code,{children:"T"})," satisfies the condition ",(0,s.jsx)(t.code,{children:"C"}),"; if so, it returns a default-constructed instance of ",(0,s.jsx)(t.code,{children:"T"}),". The second ",(0,s.jsx)(t.code,{children:"if"})," condition, ",(0,s.jsx)(t.code,{children:"sizeof...(Ts) >= 1"}),", checks if there are more types in ",(0,s.jsx)(t.code,{children:"Ts..."})," to examine; if so, it recursively calls ",(0,s.jsx)(t.code,{children:"find_type()"})," with ",(0,s.jsx)(t.code,{children:"Ts..."})," to continue the search. Finally, if ",(0,s.jsx)(t.code,{children:"Ts..."})," is empty, it returns ",(0,s.jsx)(t.code,{children:"void()"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Since the return type of ",(0,s.jsx)(t.code,{children:"find_type()"})," is ",(0,s.jsx)(t.code,{children:"auto"}),", the compiler will deduce the return type at compile time from the ",(0,s.jsx)(t.code,{children:"return"})," statement in the branch that is taken. Additionally, ",(0,s.jsx)(t.a,{href:"http://en.cppreference.com/w/cpp/language/if#Constexpr_If",children:(0,s.jsx)(t.code,{children:"if constexpr"})})," discards the unused conditional paths at compile time, so ",(0,s.jsx)(t.code,{children:"find_type()"})," compiles successfully even though it has multiple ",(0,s.jsx)(t.code,{children:"return"})," statements with different types."]}),"\n",(0,s.jsxs)(t.p,{children:["Since ",(0,s.jsx)(t.code,{children:"find_type()"}),"'s return type is what we need, we can use ",(0,s.jsx)(t.code,{children:"decltype(find_type<...>())"})," to get the resulting type. The ",(0,s.jsx)(t.code,{children:"throw;"})," statement on the first line of ",(0,s.jsx)(t.code,{children:"find_type()"})," is not strictly necessary, but it's there to indicate that ",(0,s.jsx)(t.code,{children:"find_type()"})," is not meant to be called at runtime."]}),"\n",(0,s.jsxs)(t.p,{children:["The following code defines a ",(0,s.jsx)(t.code,{children:"BinaryFloatOrVoid"})," type alias using ",(0,s.jsx)(t.code,{children:"decltype(find_type<...>())"}),". This new type will be an IEEE 754 floating-point type that matches the given storage, exponent, and mantissa bits, or it will be ",(0,s.jsx)(t.code,{children:"void"})," if the search fails."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"\ntemplate <int storage_bits,\n          int exponent_bits =\n              standard_binary_interchange_format_exponent_bits<storage_bits>(),\n          int mantissa_bits =\n              standard_binary_interchange_format_mantissa_bits<storage_bits>()>\nusing BinaryFloatOrVoid =\n    decltype(find_type<                                                //\n             Is_Ieee754_2008_Binary_Interchange_Format<storage_bits,   //\n                                                       exponent_bits,  //\n                                                       mantissa_bits>,\n             float, double, long double>());\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The functions ",(0,s.jsx)(t.code,{children:"standard_binary_interchange_format_exponent_bits()"})," and ",(0,s.jsx)(t.code,{children:"standard_binary_interchange_format_mantissa_bits()"})," return the standard number of exponent and mantissa bits, respectively. We set them as default values for ",(0,s.jsx)(t.code,{children:"exponent_bits"})," and ",(0,s.jsx)(t.code,{children:"mantissa_bits"})," for convenience. I will omit their implementations, as they are straightforward."]}),"\n",(0,s.jsxs)(t.p,{children:["Before ",(0,s.jsx)(t.code,{children:"if constexpr"})," was added in C++17, this kind of compile-time type manipulation was typically implemented with ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error",children:"SFINAE"}),". The following code shows how this can be done using that approach:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:"// Recursion termination: Type not found.\ntemplate <typename C, typename... Ts>\nstruct FindType {\n  using type = void;\n};\n\n// Recursion\ntemplate <typename C, typename T, typename... Ts>\nstruct FindType<C, T, Ts...> {\n  // Set `type = T` if T satisfies condition C; otherwise, keep\n  // searching in the remaining types, Ts...\n  using type = ::std::conditional_t<  //\n      C::template value<T>, T, typename FindType<C, Ts...>::type>;\n};\n\ntemplate <int storage_bits,\n          int exponent_bits =\n              standard_binary_interchange_format_exponent_bits<storage_bits>(),\n          int mantissa_bits =\n              standard_binary_interchange_format_mantissa_bits<storage_bits>()>\nusing BinaryFloatOrVoid = typename FindType<                  //\n    Is_Ieee754_2008_Binary_Interchange_Format<storage_bits,   //\n                                              exponent_bits,  //\n                                              mantissa_bits>,\n    float, double, long double>::type;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Clearly, the ",(0,s.jsx)(t.code,{children:"if constexpr"}),' version is simpler and much more readable. I expect to see less of the "SFINAE mess" in the future, thanks to ',(0,s.jsx)(t.code,{children:"if constexpr"})," and, hopefully, ",(0,s.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)",children:"concepts"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Finally, we introduce another type layer to produce a compile-time error with a clear message if the requested type is not available (i.e., ",(0,s.jsx)(t.code,{children:"BinaryFloatOrVoid"})," is ",(0,s.jsx)(t.code,{children:"void"}),")."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:'template <typename T>\nstruct AssertTypeFound {\n  static_assert(\n      !::std::is_same_v<T, void>,\n      "No corresponding IEEE 754-2008 binary interchange format found.");\n  using type = T;\n};\n\ntemplate <int storage_bits>\nusing IEEE_754_2008_Binary = typename AssertTypeFound<\n    BinaryFloatOrVoid<storage_bits>>::type;\n'})}),"\n",(0,s.jsxs)(t.p,{children:["OK, we have finally constructed the type ",(0,s.jsx)(t.code,{children:"IEEE_754_2008_Binary<n>"})," that guarantees conformance to the IEEE 754 standard binary interchange format. Yay!"]}),"\n",(0,s.jsx)(t.p,{children:"So are we done? Not quite. There's one last step that every programmer loves: writing tests. :)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-cpp",children:'template <int storage_bits, int exponent_bits, int mantissa_bits>\nvoid test_if_type_exists() {\n  throw;\n\n  if constexpr (!::std::is_same_v<BinaryFloatOrVoid<storage_bits>, void>) {\n    using T = IEEE_754_2008_Binary<storage_bits>;\n    static_assert(::std::is_floating_point<T>(), "");\n    static_assert(::std::numeric_limits<T>::is_iec559, "");\n    static_assert(::std::numeric_limits<T>::radix == 2, "");\n    static_assert(get_storage_bits<T>() == storage_bits, "");\n    static_assert(get_exponent_bits<T>() == exponent_bits, "");\n    static_assert(get_mantissa_bits<T>() == mantissa_bits, "");\n  }\n}\n\nvoid tests() {\n  throw;\n\n  test_if_type_exists<16, 5, 10>();\n  test_if_type_exists<32, 8, 23>();\n  test_if_type_exists<64, 11, 52>();\n  test_if_type_exists<128, 15, 112>();\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Again, all the checks are done at compile time with ",(0,s.jsx)(t.code,{children:"static_assert"}),", so we don't need to call ",(0,s.jsx)(t.code,{children:"tests()"}),". We just have to ensure that the ",(0,s.jsx)(t.code,{children:"test_if_type_exists"})," functions are instantiated. If a type doesn't exist (e.g., 16- and 128-bit types on most systems), then ",(0,s.jsx)(t.code,{children:"if constexpr"})," will simply discard the checks."]}),"\n",(0,s.jsxs)(t.p,{children:["I hope you had as much fun reading this as I did writing it. The full implementation is available in this repository: ",(0,s.jsx)(t.a,{href:"https://github.com/kkimdev/ieee754-types",children:"https://github.com/kkimdev/ieee754-types"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},6807:e=>{e.exports=JSON.parse('{"permalink":"/blog/2018/06/15/IEEE-754-Floating-Point-Type-in-C++","source":"@site/blog/2018-06-15-IEEE-754-Floating-Point-Type-in-C++.md","title":"IEEE 754 Floating-Point Types in C++","description":"If you want to use IEEE 754 32-bit or 64-bit floating-point types in C++, you might think of using float and double. Unfortunately, the C++ standard offers very few guarantees about its built-in floating-point types.","date":"2018-06-15T00:00:00.000Z","tags":[],"readingTime":7.64,"hasTruncateMarker":true,"authors":[{"name":"Kibeom Kim","url":"/","imageURL":"https://github.com/kkimdev.png","key":"kkimdev","page":null}],"frontMatter":{"draft":false,"title":"IEEE 754 Floating-Point Types in C++","authors":"kkimdev"},"unlisted":false,"prevItem":{"title":"Rust - Compile-Time Memory Safety","permalink":"/blog/2019/04/22/Rust-Compile-Time-Memory-Safety"}}')},9087:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var i=n(6363);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);