"use strict";(self.webpackChunkkkimdev=self.webpackChunkkkimdev||[]).push([[80],{6767:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>r,toc:()=>d});var i=n(1527),o=n(6274);const a={draft:!1,title:"IEEE 754 Floating Point Type in C++",authors:"kkimdev"},s=void 0,r={permalink:"/blog/2018/06/15/IEEE-754-Floating-Point-Type-in-C++",source:"@site/blog/2018-06-15-IEEE-754-Floating-Point-Type-in-C++.md",title:"IEEE 754 Floating Point Type in C++",description:"Let's say we want to use IEEE 754 32/64bit floating point types in C++, then",date:"2018-06-15T00:00:00.000Z",formattedDate:"June 15, 2018",tags:[],readingTime:7.14,hasTruncateMarker:!0,authors:[{name:"Kibeom Kim",url:"/",imageURL:"https://github.com/kkimdev.png",key:"kkimdev"}],frontMatter:{draft:!1,title:"IEEE 754 Floating Point Type in C++",authors:"kkimdev"},unlisted:!1,prevItem:{title:"Rust - Compile Time Memory Safety",permalink:"/blog/2019/04/22/Rust-Compile-Time-Memory-Safety"}},l={authorsImageUrls:[void 0]},d=[];function p(t){const e={code:"code",p:"p",...(0,o.a)(),...t.components};return(0,i.jsxs)(e.p,{children:["Let's say we want to use IEEE 754 32/64bit floating point types in C++, then\nthere is ",(0,i.jsx)(e.code,{children:"float"})," and ",(0,i.jsx)(e.code,{children:"double"})," right? Unfortunately, C++ standard guarantees\nalmost nothing about the built-in floating point types."]})}function m(t={}){const{wrapper:e}={...(0,o.a)(),...t.components};return e?(0,i.jsx)(e,{...t,children:(0,i.jsx)(p,{...t})}):p(t)}}}]);