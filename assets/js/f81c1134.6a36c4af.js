"use strict";(globalThis.webpackChunkkkimdev=globalThis.webpackChunkkkimdev||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"/2019/04/22/Rust-Compile-Time-Memory-Safety","metadata":{"permalink":"/blog/2019/04/22/Rust-Compile-Time-Memory-Safety","source":"@site/blog/2019-04-22-Rust-Compile-Time-Memory-Safety.md","title":"Rust - Compile-Time Memory Safety","description":"In this post, I will explain what makes Rust interesting by drawing an analogy between dynamic vs. static typing and the approaches to memory safety in C++ and Rust, without going into too much detail.","date":"2019-04-22T00:00:00.000Z","tags":[],"readingTime":6.86,"hasTruncateMarker":true,"authors":[{"name":"Kibeom Kim","url":"/","imageURL":"https://github.com/kkimdev.png","key":"kkimdev","page":null}],"frontMatter":{"draft":false,"title":"Rust - Compile-Time Memory Safety","authors":"kkimdev"},"unlisted":false,"nextItem":{"title":"IEEE 754 Floating-Point Types in C++","permalink":"/blog/2018/06/15/IEEE-754-Floating-Point-Type-in-C++"}},"content":"In this post, I will explain what makes Rust interesting by drawing an analogy between dynamic vs. static typing and the approaches to memory safety in C++ and Rust, without going into too much detail.\\n\\n\x3c!--truncate--\x3e\\n\\n# Preventing Type Errors at Compile Time\\n\\nStatic typing prevents type errors at compile time. For example:\\n\\n- Python\\n\\n  ```python\\n  def square(x):\\n      return x * x\\n\\n  square(\\"5\\")\\n  # Runtime error: Can\'t multiply sequence by non-int of type \'str\'\\n  ```\\n\\n- C++\\n\\n  ```cpp\\n  int square(int x) {\\n      return x * x;\\n  }\\n\\n  square(\\"5\\");\\n  // Compile error: Invalid conversion from \u2018const char*\u2019 to \u2018int\u2019\\n  ```\\n\\nStatic typing has the following benefits (taken from\\n[Guido van Rossum\'s Stanford seminar](https://www.youtube.com/watch?v=GiZKuyLKvAA&t=702)):\\n\\n- Catches (certain) bugs earlier\\n- Refactor with confidence\\n- Helps human readers navigate large codebases\\n- Better than (certain) comments: the compiler keeps you honest\\n\\nIn fact, all popular dynamic languages have static typing projects, often backed\\nby big corporations, as the benefits of static typing become more significant for\\nlarger projects.\\n\\n- Python: [PEP 484 Type Hints](https://www.python.org/dev/peps/pep-0484/),\\n  [Dropbox Mypy](http://mypy-lang.org/index.html)\\n- JavaScript: [Microsoft TypeScript](https://www.typescriptlang.org/),\\n  [Google Closure](https://developers.google.com/closure/compiler/),\\n  [Facebook Flow](https://flow.org/)\\n- Ruby: [Stripe Sorbet](https://sorbet.org/)\\n- PHP: [Facebook Hack](https://hacklang.org/)\\n- Lua: [Ravi](https://github.com/dibyendumajumdar/ravi)\\n\\n# Preventing Memory Errors at Compile Time\\n\\nSince memory safety is a major practical issue in C++, it would be great if we\\ncould check for memory errors statically, in the same way that static typing checks for type errors.\\n\\nIndeed, this was one of the main motivations behind Rust\'s creation. Just as a C++ compiler tracks type information for each variable, the Rust compiler also tracks ownership, lifetime, and aliasing for each variable.\\n\\nHere is a small list of memory issues that can be statically verified with Rust.\\n\\n#### Using an Uninitialized Variable\\n\\n- C++\\n\\n  ```cpp\\n  int x;\\n  int y = square(x);\\n  // Passing a garbage value at runtime.\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  let x: i32;\\n  let y = square(x);\\n  // Compile error\\n  // error[E0381]: use of possibly uninitialized variable: `x`\\n  //   |\\n  //   | let y = square(x);\\n  //   |                ^ use of possibly uninitialized `x`\\n  ```\\n\\n#### Invalid Memory Access\\n\\n- C++\\n\\n  ```cpp\\n  int* x = (int*)1234;\\n  *x = 5;\\n  // Invalid memory access at runtime.\\n  // Segmentation fault (core dumped)\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  let x = 1234 as *mut i32;\\n  *x = 5;\\n  // Compile error\\n  // error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\\n  //   |\\n  //   | *x = 5;\\n  //   | ^^^^^^ dereference of raw pointer\\n  //   |\\n  //   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\\n  ```\\n\\n#### Dangling Pointer/Variable\\n\\n- C++\\n\\n  ```cpp\\n  #include <string>\\n  #include <string_view>\\n\\n  std::string_view get_extension(std::string filename) {\\n      return filename.substr(filename.find_last_of(\'.\') + 1);\\n      // Returning a dangling std::string_view at runtime.\\n  }\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  fn get_extension(filename: String) -> &\'static str {\\n      return &filename[filename.rfind(\'.\').unwrap() + 1..];\\n      // Compile error\\n      // error[E0515]: cannot return value referencing function parameter `filename`\\n      //   |\\n      //   | return &filename[filename.rfind(\'.\').unwrap()+1..];\\n      //   |        ^--------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n      //   |        ||\\n      //   |        |`filename` is borrowed here\\n      //   |        returns a value referencing data owned by the current function\\n  }\\n  ```\\n\\n#### Incorrectly Using a Moved Object\\n\\n- C++\\n\\n  ```cpp\\n  #include <vector>\\n\\n  void process(std::vector<int> v);\\n\\n  // ...\\n  std::vector<int> x = {1, 2, 3};\\n  process(std::move(x));\\n  x.push_back(4);\\n  // Using an object in an unspecified state at runtime.\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  fn process(v: Vec<i32>);\\n\\n  // ...\\n  let mut x = vec![1, 2, 3];\\n  process(x);\\n  x.push(4);\\n  // Compile error\\n  // error[E0382]: borrow of moved value: `x`\\n  //   |\\n  //   | let mut x = vec![1, 2, 3];\\n  //   |     ----- move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\\n  //   | process(x);\\n  //   |         - value moved here\\n  //   | x.push(4);\\n  //   | ^ value borrowed here after move\\n  ```\\n\\n#### Data Race in Multithreading\\n\\n- C++\\n\\n  ```cpp\\n  #include <iostream>\\n  #include <thread>\\n  #include <vector>\\n\\n  static int MONEY = 0;\\n\\n  void deposit_money(int amount) {\\n      for (int i = 0; i < amount; ++i)\\n          ++MONEY;\\n          // A data race occurs at runtime. Some increments can be lost.\\n  }\\n\\n  int main() {\\n      std::vector<std::thread> threads;\\n\\n      for(int i = 0; i < 100; ++i)\\n          threads.emplace_back(deposit_money, 10000);\\n\\n      for(int i = 0; i < 100; ++i)\\n          threads[i].join();\\n\\n      // The result might not be 1,000,000 due to the data race.\\n      std::cout << MONEY;\\n  }\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  static mut MONEY: i32 = 0;\\n\\n  fn deposit_money(amount: i32) {\\n      for _ in 0..amount {\\n          MONEY += 1;\\n          // Compile error\\n          // error[E0133]: use of mutable static is unsafe and requires unsafe function or block\\n          //   |\\n          //   |     MONEY += 1;\\n          //   |     ^^^^^^^^^^ use of mutable static\\n          //   |\\n          //   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\\n      }\\n  }\\n\\n  fn main() {\\n      let mut threads = vec![];\\n\\n      for _ in 0..100 {\\n          let thread = std::thread::spawn(|| deposit_money(10000));\\n          threads.push(thread);\\n      }\\n\\n      for thread in threads {\\n          let _ = thread.join();\\n      }\\n\\n      unsafe {\\n          println!(\\"{}\\", MONEY);\\n      }\\n  }\\n  ```\\n\\nTo make these static memory checks possible, Rust enforces that you can have either a single mutable reference or multiple read-only references at a time, but not both. In fact, these are very good idioms for structuring large codebases anyway, and they normally do not get in the way of writing ordinary applications. For libraries that require fine-grained memory control, like data containers (e.g., vectors, lists, and hash maps), the\\n[`unsafe` keyword](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) is\\navailable to bypass these restrictions.\\n\\nTo be fair, there are compiler options and external tools that can detect C++ memory issues, but they are nowhere near as complete as Rust\'s built-in checks due to implementation complexity and inherent limitations in the C++ language specification.\\n\\n- `-Wall -Wextra` compiler options: Even for the trivial examples above, GCC 8.3\\n  and Clang 8.0 could only detect one of the five cases: the use of an uninitialized variable.\\n- External tools (e.g., Valgrind, Address/Memory/Thread Sanitizers): These are\\n  great tools. However, in practice, there is a big difference between compile-time and run-time detection. Run-time checks are limited to the specific code paths your tests execute. If that were sufficient, one could argue there would be no need for static typing, as tests could also be used to catch type errors.\\n\\n# How Rust Is Received\\n\\nRust has been consistently ranked #1 in\\n[the Stack Overflow Developer Survey\'s \\"most loved\\" programming languages category](https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-languages)\\nfor four years in a row, followed by Python #2, TypeScript #3, and Kotlin #4\\nin 2019.\\n\\nIt has also received favorable comments from some of the most highly regarded C/C++\\nprogrammers:\\n\\n- [John Carmack](https://en.wikipedia.org/wiki/John_Carmack):\\n  [\\"...writing Rust code feels very wholesome.\\"](https://twitter.com/id_aa_carmack/status/1094419108781789184?lang=en)\\n- [Linus Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds):\\n  [\\"...We\'ve had the system people who used Modula-2 or Ada, and I have to say Rust looks a lot better than either of those two disasters.\\"](https://www.infoworld.com/article/3109150/linux-at-25-linus-torvalds-on-the-evolution-and-future-of-linux.html)\\n- [Miguel de Icaza](https://en.wikipedia.org/wiki/Miguel_de_Icaza):\\n  [\\"...I have been following an OS written entirely in Rust, and it has great idioms.\\"](https://www.reddit.com/r/programmerchat/comments/4dxpcp/i_am_miguel_de_icaza_i_started_xamarin_mono_gnome/d1ve1k5?utm_source=share&utm_medium=web2x)\\n\\n# Rust in Production\\n\\n- [Google\'s Crosvm (ChromeOS Virtual Machine Manager)](https://chromium.googlesource.com/chromiumos/platform/crosvm/)\\n- [Facebook\'s Mercurial server](https://www.theregister.co.uk/2016/10/18/facebook_mercurial_devs_forget_git/)\\n- [Amazon\'s AWS Firecracker](https://aws.amazon.com/blogs/opensource/firecracker-open-source-secure-and-fast-microvm-for-serverless-computing/)\\n- [Microsoft\'s Azure IoT Edge](https://github.com/Azure/iotedge/tree/master/edgelet)\\n- [Red Hat\'s Stratis storage](https://github.com/stratis-storage)\\n- [Dropbox\'s storage optimization engine](https://dropbox.tech/infrastructure/rewriting-the-heart-of-our-sync-engine)\\n- [Mozilla\'s Servo browser engine](https://servo.org/)\\n- [Cloudflare\'s QUIC protocol implementation](https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/)\\n- [NPM\'s authorization service](https://www.infoq.com/presentations/rust-npm-registry/)\\n- [Unity\'s data engineering team](https://twitter.com/bltroutwine/status/1002234680949719040)\\n- [Twitter\'s build team](https://twitter.com/stuhood/status/978410393944047617?s=19)\\n- [Reddit\'s comment processing](https://www.reddit.com/r/rust/comments/7utj4t/reddit_is_hiring_a_senior_rust_engineer/)\\n\\n# Conclusion\\n\\nThis is just one example of why Rust is compelling, and there are many other\\nthings that Rust gets right. Hopefully, this post was interesting enough to encourage you to\\nread more about Rust!\\n\\n# References\\n\\n- [https://www.jonathanturner.org/2017/10/fun-facts-about-rust-growth.html](https://www.jonathanturner.org/2017/10/fun-facts-about-rust-growth.html)\\n- [https://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html](https://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html)\\n- [https://users.rust-lang.org/t/rust-quotes-and-press/5405](https://users.rust-lang.org/t/rust-quotes-and-press/5405)\\n- [https://www.rust-lang.org/production/users](https://www.rust-lang.org/production/users)"},{"id":"/2018/06/15/IEEE-754-Floating-Point-Type-in-C++","metadata":{"permalink":"/blog/2018/06/15/IEEE-754-Floating-Point-Type-in-C++","source":"@site/blog/2018-06-15-IEEE-754-Floating-Point-Type-in-C++.md","title":"IEEE 754 Floating-Point Types in C++","description":"If you want to use IEEE 754 32-bit or 64-bit floating-point types in C++, you might think of using float and double. Unfortunately, the C++ standard offers very few guarantees about its built-in floating-point types.","date":"2018-06-15T00:00:00.000Z","tags":[],"readingTime":7.64,"hasTruncateMarker":true,"authors":[{"name":"Kibeom Kim","url":"/","imageURL":"https://github.com/kkimdev.png","key":"kkimdev","page":null}],"frontMatter":{"draft":false,"title":"IEEE 754 Floating-Point Types in C++","authors":"kkimdev"},"unlisted":false,"prevItem":{"title":"Rust - Compile-Time Memory Safety","permalink":"/blog/2019/04/22/Rust-Compile-Time-Memory-Safety"}},"content":"If you want to use IEEE 754 32-bit or 64-bit floating-point types in C++, you might think of using `float` and `double`. Unfortunately, the C++ standard offers very few guarantees about its built-in floating-point types.\\n\\n\x3c!--truncate--\x3e\\n\\n> [\xa7 6.7.1.8](http://eel.is/c++draft/basic.fundamental#8) There are three\\n> floating-point types: float, double, and long double. The type double provides\\n> at least as much precision as float, and the type long double provides at\\n> least as much precision as double. The set of values of the type float is a\\n> subset of the set of values of the type double; the set of values of the type\\n> double is a subset of the set of values of the type long double. **The value\\n> representation of floating-point types is implementation-defined**. ...\\n\\nSo, are we doomed? Not at all. C++ provides [`std::numeric_limits`](http://en.cppreference.com/w/cpp/types/numeric_limits), which gives us information about floating-point type traits. We can combine this with some neat compile-time tricks to craft a clean type API. Let\'s see how. The goal is to construct the following IEEE 754 floating-point types:\\n\\n```cpp\\n#include <iostream>\\n#include \\"ieee754_types.hpp\\"\\n\\nint main() {\\n  IEEE_754_2008_Binary<32> x = 1.0;\\n  IEEE_754_2008_Binary<64> y = 2.0;\\n\\n  std::cout << x + y << std::endl;\\n\\n  // Compile-time error if the requested type doesn\'t exist on the system.\\n  // IEEE_754_2008_Binary<16> z;\\n}\\n```\\n\\nHere, `IEEE_754_2008_Binary<n>` is an n-bit IEEE 754 floating-point type. On most systems, `IEEE_754_2008_Binary<32>` will be `float` and `IEEE_754_2008_Binary<64>` will be `double`. If a requested type like `IEEE_754_2008_Binary<16>` is not available, we should get a compile-time error with a clear message.\\n\\nAt this point, you might naturally ask, \\"Do we really need this? Can\'t we just assume `float` and `double` are IEEE 754, since they are on 99.9% of systems?\\" I used to think so, but I later found that others have submitted related proposals, like [N1703](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1703.pdf) and [N3626](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3626.pdf), to the C and C++ standards committees to address this issue by adding standard types like `float16_t`, `float32_t`, `float64_t`, and `float128_t`. So, perhaps this effort isn\'t entirely pointless. With that, let\'s get started.\\n\\nFirst, let\'s create a way to check if a given type `T` fulfills the IEEE 754 standard and our other conditions.\\n\\n```cpp\\ntemplate <int storage_bits, int exponent_bits, int mantissa_bits>\\nstruct Is_Ieee754_2008_Binary_Interchange_Format {\\n  template <typename T>\\n  static constexpr bool value =\\n      ::std::is_floating_point<T>()            &&\\n      ::std::numeric_limits<T>::is_iec559      &&\\n      ::std::numeric_limits<T>::radix == 2     &&\\n      get_storage_bits<T>() == storage_bits    &&\\n      get_exponent_bits<T>() == exponent_bits  &&\\n      get_mantissa_bits<T>() == mantissa_bits;\\n};\\n```\\n\\nWe use a [variable template](https://en.cppreference.com/w/cpp/language/variable_template) for the type-dependent boolean check and wrap it in a template `struct`. This makes it easy to pass around as a type template parameter later.\\n\\nFirst, we check if `T` complies with IEEE 754 (equivalently, [IEC 60559](https://www.iso.org/standard/57469.html)) using [`std::numeric_limits<T>::is_iec559`](https://en.cppreference.com/w/cpp/types/numeric_limits/is_iec559). We also check `radix == 2` because IEEE 754 defines two types of floating-point numbers: binary and decimal. Finally, we check if `T` has the requested number of storage (width), exponent, and mantissa bits. Although IEEE 754 defines a standard number of exponent and mantissa bits for certain sizes (16, 32, 64, 128, etc.), it also allows implementations to have arbitrary sizes and bit counts (e.g., the [x86 extended precision format](https://en.wikipedia.org/wiki/Extended_precision#x86_extended_precision_format)). Therefore, we need to check that `T` has the exact format we want.\\n\\nWe can calculate the number of bits for `T` with the following simple compile-time functions:\\n\\n```cpp\\ntemplate <typename T>\\nconstexpr int get_storage_bits() {\\n  return sizeof(T) * CHAR_BIT;\\n}\\n\\ntemplate <typename T>\\nconstexpr int get_exponent_bits() {\\n  int exponent_range = ::std::numeric_limits<T>::max_exponent -\\n                       ::std::numeric_limits<T>::min_exponent;\\n  int bits = 0;\\n  while ((exponent_range >> bits) > 0) ++bits;\\n  return bits;\\n}\\n\\ntemplate <typename T>\\nconstexpr int get_mantissa_bits() {\\n  return ::std::numeric_limits<T>::digits - 1;\\n}\\n```\\n\\nFor the mantissa bits, `std::numeric_limits<T>::digits` includes the implicit leading bit for normalized numbers, so we subtract 1 to get the number of explicit mantissa bits. For the exponent bits, a direct property is not available in `std::numeric_limits`, so we instead calculate the minimum number of bits required to represent its exponent range.\\n\\nNow we have everything needed to determine if a given `T` is the type we\'re looking for. The next step is to automatically select such a type from the built-in floating-point types (`float`, `double`, and `long double`), given a size in bits (e.g., 32, 64). This is where it gets interesting.\\n\\nThe following recursive function, `find_type()`, selects a type from `T` and `Ts...` that satisfies the condition `C`.\\n\\n```cpp\\ntemplate <typename C, typename T, typename... Ts>\\nconstexpr auto find_type() {\\n  throw;\\n\\n  if constexpr (C::template value<T>) {\\n    return T();\\n  } else if constexpr (sizeof...(Ts) >= 1) {\\n    return find_type<C, Ts...>();\\n  } else {\\n    return void();\\n  }\\n}\\n```\\n\\nIn our case, the types to search (`T` and `Ts...`) will be `float`, `double`, and `long double`. The condition `C` is the `Is_Ieee754_2008_Binary_Interchange_Format<...>` struct we defined previously.\\n\\n`typename... Ts` is a [parameter pack](https://en.cppreference.com/w/cpp/language/parameter_pack) that can match any number of types. The first `if` condition, `C::template value<T>`, checks if `T` satisfies the condition `C`; if so, it returns a default-constructed instance of `T`. The second `if` condition, `sizeof...(Ts) >= 1`, checks if there are more types in `Ts...` to examine; if so, it recursively calls `find_type()` with `Ts...` to continue the search. Finally, if `Ts...` is empty, it returns `void()`.\\n\\nSince the return type of `find_type()` is `auto`, the compiler will deduce the return type at compile time from the `return` statement in the branch that is taken. Additionally, [`if constexpr`](http://en.cppreference.com/w/cpp/language/if#Constexpr_If) discards the unused conditional paths at compile time, so `find_type()` compiles successfully even though it has multiple `return` statements with different types.\\n\\nSince `find_type()`\'s return type is what we need, we can use `decltype(find_type<...>())` to get the resulting type. The `throw;` statement on the first line of `find_type()` is not strictly necessary, but it\'s there to indicate that `find_type()` is not meant to be called at runtime.\\n\\nThe following code defines a `BinaryFloatOrVoid` type alias using `decltype(find_type<...>())`. This new type will be an IEEE 754 floating-point type that matches the given storage, exponent, and mantissa bits, or it will be `void` if the search fails.\\n\\n```cpp\\n\\ntemplate <int storage_bits,\\n          int exponent_bits =\\n              standard_binary_interchange_format_exponent_bits<storage_bits>(),\\n          int mantissa_bits =\\n              standard_binary_interchange_format_mantissa_bits<storage_bits>()>\\nusing BinaryFloatOrVoid =\\n    decltype(find_type<                                                //\\n             Is_Ieee754_2008_Binary_Interchange_Format<storage_bits,   //\\n                                                       exponent_bits,  //\\n                                                       mantissa_bits>,\\n             float, double, long double>());\\n```\\n\\nThe functions `standard_binary_interchange_format_exponent_bits()` and `standard_binary_interchange_format_mantissa_bits()` return the standard number of exponent and mantissa bits, respectively. We set them as default values for `exponent_bits` and `mantissa_bits` for convenience. I will omit their implementations, as they are straightforward.\\n\\nBefore `if constexpr` was added in C++17, this kind of compile-time type manipulation was typically implemented with [SFINAE](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error). The following code shows how this can be done using that approach:\\n\\n```cpp\\n// Recursion termination: Type not found.\\ntemplate <typename C, typename... Ts>\\nstruct FindType {\\n  using type = void;\\n};\\n\\n// Recursion\\ntemplate <typename C, typename T, typename... Ts>\\nstruct FindType<C, T, Ts...> {\\n  // Set `type = T` if T satisfies condition C; otherwise, keep\\n  // searching in the remaining types, Ts...\\n  using type = ::std::conditional_t<  //\\n      C::template value<T>, T, typename FindType<C, Ts...>::type>;\\n};\\n\\ntemplate <int storage_bits,\\n          int exponent_bits =\\n              standard_binary_interchange_format_exponent_bits<storage_bits>(),\\n          int mantissa_bits =\\n              standard_binary_interchange_format_mantissa_bits<storage_bits>()>\\nusing BinaryFloatOrVoid = typename FindType<                  //\\n    Is_Ieee754_2008_Binary_Interchange_Format<storage_bits,   //\\n                                              exponent_bits,  //\\n                                              mantissa_bits>,\\n    float, double, long double>::type;\\n```\\n\\nClearly, the `if constexpr` version is simpler and much more readable. I expect to see less of the \\"SFINAE mess\\" in the future, thanks to `if constexpr` and, hopefully, [concepts](<https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)>).\\n\\nFinally, we introduce another type layer to produce a compile-time error with a clear message if the requested type is not available (i.e., `BinaryFloatOrVoid` is `void`).\\n\\n```cpp\\ntemplate <typename T>\\nstruct AssertTypeFound {\\n  static_assert(\\n      !::std::is_same_v<T, void>,\\n      \\"No corresponding IEEE 754-2008 binary interchange format found.\\");\\n  using type = T;\\n};\\n\\ntemplate <int storage_bits>\\nusing IEEE_754_2008_Binary = typename AssertTypeFound<\\n    BinaryFloatOrVoid<storage_bits>>::type;\\n```\\n\\nOK, we have finally constructed the type `IEEE_754_2008_Binary<n>` that guarantees conformance to the IEEE 754 standard binary interchange format. Yay!\\n\\nSo are we done? Not quite. There\'s one last step that every programmer loves: writing tests. :)\\n\\n```cpp\\ntemplate <int storage_bits, int exponent_bits, int mantissa_bits>\\nvoid test_if_type_exists() {\\n  throw;\\n\\n  if constexpr (!::std::is_same_v<BinaryFloatOrVoid<storage_bits>, void>) {\\n    using T = IEEE_754_2008_Binary<storage_bits>;\\n    static_assert(::std::is_floating_point<T>(), \\"\\");\\n    static_assert(::std::numeric_limits<T>::is_iec559, \\"\\");\\n    static_assert(::std::numeric_limits<T>::radix == 2, \\"\\");\\n    static_assert(get_storage_bits<T>() == storage_bits, \\"\\");\\n    static_assert(get_exponent_bits<T>() == exponent_bits, \\"\\");\\n    static_assert(get_mantissa_bits<T>() == mantissa_bits, \\"\\");\\n  }\\n}\\n\\nvoid tests() {\\n  throw;\\n\\n  test_if_type_exists<16, 5, 10>();\\n  test_if_type_exists<32, 8, 23>();\\n  test_if_type_exists<64, 11, 52>();\\n  test_if_type_exists<128, 15, 112>();\\n}\\n```\\n\\nAgain, all the checks are done at compile time with `static_assert`, so we don\'t need to call `tests()`. We just have to ensure that the `test_if_type_exists` functions are instantiated. If a type doesn\'t exist (e.g., 16- and 128-bit types on most systems), then `if constexpr` will simply discard the checks.\\n\\nI hope you had as much fun reading this as I did writing it. The full implementation is available in this repository: https://github.com/kkimdev/ieee754-types."}]}}')}}]);