"use strict";(self.webpackChunkkkimdev=self.webpackChunkkkimdev||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2019/04/22/Rust-Compile-Time-Memory-Safety","metadata":{"permalink":"/blog/2019/04/22/Rust-Compile-Time-Memory-Safety","source":"@site/blog/2019-04-22-Rust-Compile-Time-Memory-Safety.md","title":"Rust - Compile Time Memory Safety","description":"In this post, I will explain why Rust is interesting by making an analogy","date":"2019-04-22T00:00:00.000Z","formattedDate":"April 22, 2019","tags":[],"readingTime":6.025,"hasTruncateMarker":true,"authors":[{"name":"Kibeom Kim","url":"/","imageURL":"https://github.com/kkimdev.png","key":"kkimdev"}],"frontMatter":{"draft":false,"title":"Rust - Compile Time Memory Safety","authors":"kkimdev"},"unlisted":false,"nextItem":{"title":"IEEE 754 Floating Point Type in C++","permalink":"/blog/2018/06/15/IEEE-754-Floating-Point-Type-in-C++"}},"content":"In this post, I will explain why Rust is interesting by making an analogy\\nbetween \\"dynamic vs static typing\\" and \\"C++ vs Rust\'s static memory safety\\"\\nwithout going into too much detail.\\n\\n\x3c!--truncate--\x3e\\n\\n# Preventing type errors at compile time\\n\\nStatic typing prevents type errors at compile time, for example,\\n\\n- Python\\n\\n  ```python\\n  def square(x):\\n      return x * x\\n\\n  square(\\"5\\")\\n  # Runtime error: Can\'t multiply sequence by non-int of type \'str\'\\n  ```\\n\\n- C++\\n\\n  ```cpp\\n  int square(int x) {\\n      return x * x;\\n  }\\n\\n  square(\\"5\\");\\n  // Compile error: Invalid conversion from \u2018const char*\u2019 to \u2018int\u2019\\n  ```\\n\\nStatic typing has the following benefits (taken from\\n[Guido Rossum\'s Stanford seminar](https://www.youtube.com/watch?v=GiZKuyLKvAA&t=702)).\\n\\n- Catches (certain) bugs earlier\\n- Refactor with confidence\\n- Helps human reader navigate large code bases\\n- Better than (certain) comments: compiler keeps you honest\\n\\nIn fact, all popular dynamic languages have static typing projects, often backed\\nby big corporations as the benefit of static typing becomes more significant for\\nlarger projects.\\n\\n- Python: [PEP 484 Type Hints](https://www.python.org/dev/peps/pep-0484/),\\n  [Dropbox Mypy](http://mypy-lang.org/index.html)\\n- Javascript: [Microsoft Typescript](https://www.typescriptlang.org/),\\n  [Google Closure](https://developers.google.com/closure/compiler/),\\n  [Facebook Flow](https://flow.org/)\\n- Ruby: [Stripe Sorbet](https://sorbet.org/)\\n- PHP: [Facebook Hack](https://hacklang.org/)\\n- Lua: [Ravi](https://github.com/dibyendumajumdar/ravi)\\n\\n# Preventing memory errors at compile time\\n\\nSince memory safety in C++ is a major practical issue, it would be great if we\\ncan check them statically in a similar manner that static typing does.\\n\\nYes, this was one of the main motivations behind the creation of Rust. Just like\\nC++ compiler tracks type information for each variable, Rust compiler tracks\\nownership, lifetime, and aliasing for each variable in addition.\\n\\nHere is a small list of memory issues that can be statically verified with Rust.\\n\\n#### Using uninitialized variable\\n\\n- C++\\n\\n  ```cpp\\n  int x;\\n  int y = square(x);\\n  // Passing a garbage value at runtime.\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  let mut x: i32;\\n  let mut y = square(x);\\n  // Compile error\\n  // error[E0381]: use of possibly uninitialized variable: `x`\\n  //   |\\n  //   | let mut y = square(x);\\n  //   |                    ^ use of possibly uninitialized `x`\\n  ```\\n\\n#### Invalid memory access\\n\\n- C++\\n\\n  ```cpp\\n  int* x = (int*)1234;\\n  *x = 5;\\n  // Runtime invalid memory access\\n  // Segmentation fault (core dumped)\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  let x = 1234 as *mut i32;\\n  *x = 5;\\n  // Compile error\\n  // error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block\\n  //   |\\n  //   | *x = 5;\\n  //   | ^^^^^^ dereference of raw pointer\\n  //   |\\n  //   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\\n  ```\\n\\n#### Dangling pointer / variable\\n\\n- C++\\n\\n  ```cpp\\n  std::string_view get_extension(std::string filename) {\\n      return filename.substr(filename.find_last_of(\'.\') + 1);\\n      // Returning dangling std::string_view at runtime.\\n  }\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  fn get_extension(filename: String) -> &\'static str {\\n      return &filename[filename.rfind(\'.\').unwrap()+1..];\\n      // Compile error\\n      // error[E0515]: cannot return value referencing function parameter `filename`\\n      //   |\\n      //   | return &filename[filename.rfind(\'.\').unwrap()+1..];\\n      //   |        ^--------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n      //   |        ||\\n      //   |        |`filename` is borrowed here\\n      //   |        returns a value referencing data owned by the current function\\n      //   }\\n      //\\n  }\\n  ```\\n\\n#### Incorrectly using a moved object\\n\\n- C++\\n\\n  ```cpp\\n  std::vector<int> x = {1, 2, 3};\\n  process(std::move(x));\\n  x.push_back(4);\\n  // Using an unspecified state object at runtime\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  let mut x = vec![1, 2, 3];\\n  process(x);\\n  x.push(4);\\n  // Compile error\\n  // error[E0382]: borrow of moved value: `x`\\n  //   |\\n  //   | let mut x = vec![1, 2, 3];\\n  //   |     ----- move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait\\n  //   | process(x);\\n  //   |         - value moved here\\n  //   | x.push(4);\\n  //   | ^ value borrowed here after move\\n  ```\\n\\n#### Data race in multithreading\\n\\n- C++\\n\\n  ```cpp\\n  #include<iostream>\\n  #include<thread>\\n  #include<vector>\\n\\n  static int MONEY = 0;\\n\\n  void deposit_money(int amount) {\\n      for (int i = 0; i < amount; ++i)\\n          ++MONEY;\\n          // Runtime data race.  Some increments can be ignored.\\n  }\\n\\n  int main() {\\n      std::vector<std::thread> threads;\\n\\n      for(int i = 0; i < 100; ++i)\\n          threads.emplace_back(deposit_money, 10000);\\n\\n      for(int i = 0; i < 100; ++i)\\n          threads[i].join();\\n\\n      // The result might not be 1000000 due to the data race.\\n      std::cout << MONEY;\\n  }\\n  ```\\n\\n- Rust\\n\\n  ```rust\\n  static mut MONEY: i32 = 0;\\n\\n  fn deposit_money(amount: i32) {\\n      for _ in 0..amount {\\n          MONEY += 1;\\n          // Compile error\\n          // error[E0133]: use of mutable static is unsafe and requires unsafe function or block\\n          //   |\\n          //   |     MONEY += 1;\\n          //   |     ^^^^^^^^^^ use of mutable static\\n          //   |\\n          //   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\\n      }\\n  }\\n\\n  fn main() {\\n      let mut threads = vec![];\\n\\n      for _ in 0..100 {\\n          let thread = std::thread::spawn(|| deposit_money(10000));\\n          threads.push(thread);\\n      }\\n\\n      for thread in threads {\\n          let _ = thread.join();\\n      }\\n\\n      println!(\\"{}\\", MONEY);\\n  }\\n  ```\\n\\nTo make these static memory checks possible, Rust enforces single mutable\\nownership or multiple read-only aliases at a time. In fact, they are very good\\nidioms to structure large codebase anyways, and normally they do not get in the\\nway for ordinary applications. For libraries that require fine-grained memory\\ncontrol like data containers, e.g., vector, list, and hash map,\\n[`unsafe` keyword](https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html) is\\navailable to bypass the restrictions.\\n\\nTo be fair, there are compiler options or external tools that we can use to\\ndetect C++ memory issues, but it\'s nowhere close to the completeness of Rust due\\nto the implementation complexity and the inherent language spec limitations.\\n\\n- `-Wall -Wextra` compiler options: Even for the above trivial examples, GCC 8.3\\n  and Clang 8.0 could only detect the one case, uninitialized variable, out of\\n  the five cases.\\n- External tools, e.g., Valgrind, Address/Memory/Thread Sanitizers: They are\\n  great tools. However in practice, being able to detect at compile time vs\\n  runtime is a big difference as the detection is limited to the specific test\\n  cases that we have. Otherwise, there would be no need for static typing for\\n  correctness as we can run tests to catch the type errors.\\n\\n# How Rust is received\\n\\nRust has been consistently ranked #1 in\\n[Stack Overflow developer survey\'s most loved programming languages category](https://insights.stackoverflow.com/survey/2019#technology-_-most-loved-dreaded-and-wanted-languages)\\nfor 4 years in a row, followed by Python #2, Typescript #3, and Kotlin #4\\nin 2019.\\n\\nAlso, it got favorable comments from some of the highly regarded C/C++\\nprogrammers:\\n\\n- [John Carmack](https://en.wikipedia.org/wiki/John_Carmack):\\n  [\\"...writing Rust code feels very wholesome.\\"](https://twitter.com/id_aa_carmack/status/1094419108781789184?lang=en)\\n- [Linus Torvalds](https://en.wikipedia.org/wiki/Linus_Torvalds):\\n  [\\"...We\'ve had the system people who used Modula-2 or Ada, and I have to say Rust looks a lot better than either of those two disasters.\\"](https://www.infoworld.com/article/3109150/linux-at-25-linus-torvalds-on-the-evolution-and-future-of-linux.html)\\n- [Miguel Icaza](https://en.wikipedia.org/wiki/Miguel_de_Icaza):\\n  [\\"...I have been following an OS written entirely in Rust, and it has great idioms.\\"](https://www.reddit.com/r/programmerchat/comments/4dxpcp/i_am_miguel_de_icaza_i_started_xamarin_mono_gnome/d1ve1k5?utm_source=share&utm_medium=web2x)\\n\\n# Rust in production\\n\\n- [Google Chrome Crosvm](https://chromium.googlesource.com/chromiumos/platform/crosvm/)\\n- [Facebook\'s new Mercurial server](https://www.theregister.co.uk/2016/10/18/facebook_mercurial_devs_forget_git/)\\n- [Amazon AWS Firecracker](https://www.reddit.com/r/rust/comments/a0rph0/aws_firecracker_microvm_is_all_rust/)\\n- [Microsoft Azure IoT Edge](https://github.com/Azure/iotedge/tree/master/edgelet)\\n- [Red Hat Stratis storage](https://github.com/stratis-storage)\\n- [Dropbox storage optimization](https://qconsf.com/sf2016/sf2016/presentation/going-rust-optimizing-storage-dropbox.html)\\n- [Mozilla Servo](https://servo.org/)\\n- [Cloudflare\'s QUIC protocol implementation](https://blog.cloudflare.com/enjoy-a-slice-of-quic-and-rust/)\\n- [NPM](https://www.youtube.com/watch?v=GCsxYAxw3JQ)\\n- [Unity data engineering](https://twitter.com/bltroutwine/status/1002234680949719040)\\n- [Twitter build team](https://twitter.com/stuhood/status/978410393944047617?s=19)\\n- [Reddit comment parsing](https://www.reddit.com/r/rust/comments/7utj4t/reddit_is_hiring_a_senior_rust_engineer/)\\n\\n# Conclusion\\n\\nThis is just one example why Rust is compelling, and there are so many other\\nthings that Rust got it right. Hopefully it was interesting enough for you to\\nread more about Rust!\\n\\n# References\\n\\n- [https://www.jonathanturner.org/2017/10/fun-facts-about-rust-growth.html](https://www.jonathanturner.org/2017/10/fun-facts-about-rust-growth.html)\\n- [https://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html](https://www.jonathanturner.org/2018/07/snapshot-of-rust-popularity.html)\\n- [https://users.rust-lang.org/t/rust-quotes-and-press/5405](https://users.rust-lang.org/t/rust-quotes-and-press/5405)\\n- [https://www.rust-lang.org/production/users](https://www.rust-lang.org/production/users)"},{"id":"/2018/06/15/IEEE-754-Floating-Point-Type-in-C++","metadata":{"permalink":"/blog/2018/06/15/IEEE-754-Floating-Point-Type-in-C++","source":"@site/blog/2018-06-15-IEEE-754-Floating-Point-Type-in-C++.md","title":"IEEE 754 Floating Point Type in C++","description":"Let\'s say we want to use IEEE 754 32/64bit floating point types in C++, then","date":"2018-06-15T00:00:00.000Z","formattedDate":"June 15, 2018","tags":[],"readingTime":7.14,"hasTruncateMarker":true,"authors":[{"name":"Kibeom Kim","url":"/","imageURL":"https://github.com/kkimdev.png","key":"kkimdev"}],"frontMatter":{"draft":false,"title":"IEEE 754 Floating Point Type in C++","authors":"kkimdev"},"unlisted":false,"prevItem":{"title":"Rust - Compile Time Memory Safety","permalink":"/blog/2019/04/22/Rust-Compile-Time-Memory-Safety"}},"content":"Let\'s say we want to use IEEE 754 32/64bit floating point types in C++, then\\nthere is `float` and `double` right? Unfortunately, C++ standard guarantees\\nalmost nothing about the built-in floating point types.\\n\\n\x3c!--truncate--\x3e\\n\\n> [\xa7 6.7.1.8](http://eel.is/c++draft/basic.fundamental#8) There are three\\n> floating-point types: float, double, and long double. The type double provides\\n> at least as much precision as float, and the type long double provides at\\n> least as much precision as double. The set of values of the type float is a\\n> subset of the set of values of the type double; the set of values of the type\\n> double is a subset of the set of values of the type long double. **The value\\n> representation of floating-point types is implementation-defined**. ...\\n\\nSo are we just doomed? No! There is\\n[std::numeric_limits](http://en.cppreference.com/w/cpp/types/numeric_limits)\\nthat gives various floating point type trait information, and neat C++ compile\\ntime tricks we can use to craft a clean type API. So let\'s try. The goal is to\\nconstruct the following IEEE754 floating point types.\\n\\n```cpp\\n#include <iostream>\\n#include \\"ieee754_types.hpp\\"\\n\\nint main() {\\n  IEEE_754_2008_Binary<32> x = 1.0;\\n  IEEE_754_2008_Binary<64> y = 2.0;\\n\\n  std::cout << x + y << std::endl;\\n\\n  // Compile time error if the requested type doesn\'t exist in the system.\\n  // IEEE_754_2008_Binary<16> z;\\n}\\n```\\n\\n`IEEE_754_2008_Binary<n>` is n-bit IEEE 754 floating point type. Of course, for\\nmost systems, `IEEE_754_2008_Binary<32>` is `float` and\\n`IEEE_754_2008_Binary<64>` is `double`. In case the requested type is not\\navailable, like `IEEE_754_2008_Binary<16>`, it should cause a compile error with\\na clear error message.\\n\\nWell, I guess a natural question at this point is: \\"Do we really need this?\\nCan\'t we just assume `float` and `double` are IEEE 754 because they actually are\\nfor the 99.9% systems out there?\\". I thought so, but then later, I\'ve found that\\npeople have submitted related proposals,\\n[N1703](http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1703.pdf),\\n[N3626](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3626.pdf), to\\nC/C++ standards committee to fix this issue with additional standard types,\\n`float16_t`, `float32_t`, `float64_t`, and `float128_t`. So maybe it\'s not\\nentirely pointless after all. Anyways, let\'s get started.\\n\\nFirst, let\'s begin with checking if a given type, `T`, fulfills IEEE 754 and\\nother desired conditions.\\n\\n```cpp\\ntemplate <int storage_bits, int exponent_bits, int mantissa_bits>\\nstruct Is_Ieee754_2008_Binary_Interchange_Format {\\n  template <typename T>\\n  static constexpr bool value =\\n      ::std::is_floating_point<T>()            &&\\n      ::std::numeric_limits<T>::is_iec559      &&\\n      ::std::numeric_limits<T>::radix == 2     &&\\n      get_storage_bits<T>() == storage_bits    &&\\n      get_exponent_bits<T>() == exponent_bits  &&\\n      get_mantissa_bits<T>() == mantissa_bits;\\n};\\n```\\n\\nWe used\\n[variable template](https://en.cppreference.com/w/cpp/language/variable_template)\\nfor the type dependent boolean value computation, and also wrapped by a template\\nstruct so that we can pass it around easily as a type template parameter later.\\n\\nFirst, we check if `T` compiles IEEE 754 (equivalently,\\n[IEC 60559](https://www.iso.org/standard/57469.html)) with\\n[`std::is_iec559`](https://en.cppreference.com/w/cpp/types/numeric_limits/is_iec559).\\nWe should also check `radix == 2` since IEEE 754 defines two types of floating\\npoints, binary and decimal. Finally, we check if `T` has the requested number of\\nstorage(width), exponent, and mantissa bits. IEEE 754 defines the standard\\nnumber of exponent and mantissa bits for certain sizes, 16, 32, 64, 128, 160,\\n..., but it also allows implementations to have arbitrary sizes and bits (e.g.,\\n[x86 extended precision format](https://en.wikipedia.org/wiki/Extended_precision#x86_extended_precision_format)),\\nso we need to check that if `T` has the exact format we want.\\n\\nWe can calculate the number of bits of `T` with the following simple compile\\ntime functions.\\n\\n```cpp\\ntemplate <typename T>\\nconstexpr int get_storage_bits() {\\n  return sizeof(T) * CHAR_BIT;\\n}\\n\\ntemplate <typename T>\\nconstexpr int get_exponent_bits() {\\n  int exponent_range = ::std::numeric_limits<T>::max_exponent -\\n                       ::std::numeric_limits<T>::min_exponent;\\n  int bits = 0;\\n  while ((exponent_range >> bits) > 0) ++bits;\\n  return bits;\\n}\\n\\ntemplate <typename T>\\nconstexpr int get_mantissa_bits() {\\n  return ::std::numeric_limits<T>::digits - 1;\\n}\\n```\\n\\nFor the mantissa bits, the leading bit is implicit so we need to subtract 1. For\\nthe exponent bits, there is no direct property available in\\n`std::numeric_limits` so instead we calculate the minimum number of bits\\nrequired to represent its exponent range.\\n\\nNow, we have everything needed to figure out if the given `T` is the type we\'re\\nlooking for. The next step is to automatically select such type among the\\nbuilt-in floating point types, `float`, `double`, and `long double`, given the\\nsize in bits, e.g., 32, 64. This is where it gets interesting.\\n\\nThe following `find_type()` recursive function selects a type among `T` and `Ts`\\nthat satisfies the condition `C`. In our case, `T` and `Ts` are\\n`float, double, long double`, and `C` is the struct we defined previously,\\n`Is_Ieee754_2008_Binary_Interchange_Format<storage_bits, exponent_bits, storage_bits, mantissa_bits>`.\\n\\n```cpp\\ntemplate <typename C, typename T, typename... Ts>\\nconstexpr auto find_type() {\\n  throw;\\n\\n  if constexpr (C::template value<T>) {\\n    return T();\\n  } else if constexpr (sizeof...(Ts) >= 1) {\\n    return find_type<C, Ts...>();\\n  } else {\\n    return void();\\n  }\\n}\\n```\\n\\n`typename... Ts` is a\\n[parameter pack](https://en.cppreference.com/w/cpp/language/parameter_pack) that\\ncan match any number of types. So `T` will be `float` and `Ts` will be\\n`double, long double`. The first if condition, `C::template value<T>` checks if\\n`T` satisfies the condition given by `C`, if so, it returns a default instance\\nof `T`. The second if condition, `sizeof...(Ts) >= 1`, checks if there are more\\ntypes in `Ts` to exam, if so, it recursively calls itself, `find_type()`, with\\n`Ts` to continue the search. Finally, if there is nothing in `Ts`, it returns a\\nvoid instance.\\n\\nNote that since the return type of `find_type()` is `auto`, the return type will\\nbe deduced to what `find_type()` returns at compile time. In addition,\\n[`if constexpr`](http://en.cppreference.com/w/cpp/language/if#Constexpr_If)\\ndiscards the unused conditional paths at compile time, so even though\\n`find_type()` has multiple return statements with different types, it compiles\\nsuccessfully.\\n\\nSince `find_type()`\'s return type is what we need, we can do\\n`decltype(find_type<...>())` to get that. The statement `throw;` at the first\\nline of `find_type()` is not necessary but it\'s there to indicate that\\n`find_type()` is not supposed to be called directly.\\n\\nThe following code defines `BinaryFloatOrVoid` type using\\n`decltype(find_type<...>())`. The newly defined type, `BinaryFloatOrVoid`, will\\nbe a IEEE754 floating point type that matches the given storage, exponent, and\\nmantissa bits, or `void` if the search fails.\\n\\n```cpp\\n\\ntemplate <int storage_bits,\\n          int exponent_bits =\\n              standard_binary_interchange_format_exponent_bits<storage_bits>(),\\n          int mantissa_bits =\\n              standard_binary_interchange_format_mantissa_bits<storage_bits>()>\\nusing BinaryFloatOrVoid =\\n    decltype(find_type<                                                //\\n             Is_Ieee754_2008_Binary_Interchange_Format<storage_bits,   //\\n                                                       exponent_bits,  //\\n                                                       mantissa_bits>,\\n             float, double, long double>());\\n```\\n\\n`standard_binary_interchange_format_exponent_bits()` and\\n`standard_binary_interchange_format_mantissa_bits()` functions just return the\\nnumber of standard exponent and mantissa bits respectively, and we set them as\\nthe default values for `exponent_bits` and `mantissa_bits` for convenience. I\\nwill omit their actual implementations as it\'s pretty straightforward and\\nuninteresting.\\n\\nTraditionally, before `if constexpr` was available in C++17, this kind of\\ncompile time type manipulation was implemented with\\n[SFINAE](https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error).\\nThe following code shows how it can be done in that way.\\n\\n```cpp\\n// Recursion termination.  Type not found.\\ntemplate <typename C, typename... Ts>\\nstruct FindType {\\n  using type = void;\\n};\\n\\n// Recursion\\ntemplate <typename C, typename T, typename... Ts>\\nstruct FindType<C, T, Ts...> {\\n  // Set `type = T` if T satisfies the condition, C.  Otherwise, keep\\n  // searching in the remaining types, Ts... .\\n  using type = ::std::conditional_t<  //\\n      C::template value<T>, T, typename FindType<C, Ts...>::type>;\\n};\\n\\ntemplate <int storage_bits,\\n          int exponent_bits =\\n              standard_binary_interchange_format_exponent_bits<storage_bits>(),\\n          int mantissa_bits =\\n              standard_binary_interchange_format_mantissa_bits<storage_bits>()>\\nusing BinaryFloatOrVoid = typename FindType<                  //\\n    Is_Ieee754_2008_Binary_Interchange_Format<storage_bits,   //\\n                                              exponent_bits,  //\\n                                              mantissa_bits>,\\n    float, double, long double>::type;\\n```\\n\\nClearly, the `if constexpr` version is simpler and a lot more readable, and I\\nexpect to see less of the SFINAE mess thanks to `if constexpr` (and hopefully\\n[concepts](<https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)>)) in the future.\\n\\nLastly, we introduce another type layer to cause a compile error with a nice\\nerror message, in case the requested type is not available, i.e.,\\n`BinaryFloatOrVoid` is `void`.\\n\\n```cpp\\ntemplate <typename T>\\nstruct AssertTypeFound {\\n  static_assert(\\n      !::std::is_same_v<T, void>,\\n      \\"No corresponding IEEE 754-2008 binary interchange format found.\\");\\n  using type = T;\\n};\\n\\ntemplate <int storage_bits>\\nusing IEEE_754_2008_Binary = typename AssertTypeFound<\\n    BinaryFloatOrVoid<storage_bits>>::type;\\n```\\n\\nOK, finally, we have constructed the type `IEEE_754_2008_Binary<n>` that\\nguarantees IEEE 754 standard binary interchange format. Yay!\\n\\nSo are we done now? Not quite, there is one last step that every programmer\\nloves: writing tests. :)\\n\\n```cpp\\ntemplate <int storage_bits, int exponent_bits, int mantissa_bits>\\nvoid test_if_type_exists() {\\n  throw;\\n\\n  if constexpr (!::std::is_same_v<BinaryFloatOrVoid<storage_bits>, void>) {\\n    using T = IEEE_754_2008_Binary<storage_bits>;\\n    static_assert(::std::is_floating_point<T>(), \\"\\");\\n    static_assert(::std::numeric_limits<T>::is_iec559, \\"\\");\\n    static_assert(::std::numeric_limits<T>::radix == 2, \\"\\");\\n    static_assert(get_storage_bits<T>() == storage_bits, \\"\\");\\n    static_assert(get_exponent_bits<T>() == exponent_bits, \\"\\");\\n    static_assert(get_mantissa_bits<T>() == mantissa_bits, \\"\\");\\n  }\\n}\\n\\nvoid tests() {\\n  throw;\\n\\n  test_if_type_exists<16, 5, 10>();\\n  test_if_type_exists<32, 8, 23>();\\n  test_if_type_exists<64, 11, 52>();\\n  test_if_type_exists<128, 15, 112>();\\n}\\n```\\n\\nAgain, all the checks are done at compile time, `static_assert`, so we don\'t\\nneed to call `test()`, and just have to ensure that `test_if_type_exists`\\nfunctions are instantiated. If a type doesn\'t exists (i.e., 16 and 128 size\\ntypes in most systems) then `if constexpr` will simply discard the checks.\\n\\nI hope you had fun, like I did. The full implementation is available in this\\nrepository https://github.com/kkimdev/ieee754-types."}]}')}}]);